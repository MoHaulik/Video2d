<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>WebXR VR Cinema - Immersive 2D Video Player</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body { margin: 0; overflow: hidden; font-family: system-ui, sans-serif; background: #111; }
    #overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 9000; background: linear-gradient(135deg, #1a1a2e, #16213e); }
    #start-button { padding: 20px 40px; font-size: 20px; background: linear-gradient(45deg, #667eea, #764ba2); color: white; border: none; border-radius: 25px; box-shadow: 0 8px 25px rgba(102,126,234,0.3); cursor: pointer; transition: all 0.3s; font-weight: 600; margin-bottom: 30px; }
    #start-button:hover { transform: translateY(-3px); box-shadow: 0 12px 35px rgba(102,126,234,0.4); }
    #file-input { display: none; }
    #file-select { padding: 15px 30px; font-size: 16px; background: rgba(255,255,255,0.1); color: white; border: 2px solid rgba(255,255,255,0.2); border-radius: 20px; cursor: pointer; transition: all 0.3s; margin-bottom: 15px; backdrop-filter: blur(10px); }
    #file-select:hover { background: rgba(255,255,255,0.2); border-color: rgba(255,255,255,0.4); }
    #selected-file { color: #a0a0a0; font-size: 14px; margin: 10px 0; text-align: center; max-width: 300px; }
    #status { position: fixed; bottom: 40px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); color: white; padding: 15px 25px; border-radius: 20px; font-size: 16px; backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.2); display: none; z-index: 9999; }
    .exit-vr { position: fixed; top: 20px; right: 20px; background: rgba(255,255,255,0.1); color: white; border: 2px solid rgba(255,255,255,0.3); border-radius: 50%; width: 50px; height: 50px; display: none; align-items: center; justify-content: center; font-size: 24px; cursor: pointer; z-index: 9999; backdrop-filter: blur(10px); }
    .vr-active .exit-vr { display: flex; }
    video { display: block; width: 400px; height: 225px; margin: 20px auto; border-radius: 12px; box-shadow: 0 8px 25px rgba(0,0,0,0.3); }
    .vr-active video { position: absolute; width: 1px; height: 1px; opacity: 0.01; }
    .cinema-title { color: white; font-size: 28px; font-weight: 300; margin-bottom: 40px; text-align: center; opacity: 0.9; }
    .instructions { color: rgba(255,255,255,0.7); font-size: 14px; text-align: center; max-width: 400px; line-height: 1.5; margin-top: 20px; }
  </style>
</head>
<body>
  <div id="overlay">
    <h1 class="cinema-title">VR Cinema</h1>
    <button id="start-button">Enter Virtual Cinema</button>
    <label id="file-select" for="file-input">Select Video File</label>
    <input type="file" id="file-input" accept="video/*">
    <div id="selected-file"></div>
    <div class="instructions">
      In VR: Grab the screen to move it around • Grab bottom-right corner to resize • Trigger to play/pause
    </div>
    <video id="video" playsinline crossorigin="anonymous" controls></video>
  </div>
  <button class="exit-vr" id="exit-vr" aria-label="Exit VR">×</button>
  <div id="status"></div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.150.1/build/three.module.js';

    // Main variables
    let camera, scene, renderer, videoScreen, controllers = [], xrSession = null;
    let videoElement, videoTexture;
    let isPlaying = false;
    let currentVideoURL = null;
    
    // Screen manipulation variables
    let isDragging = false;
    let isResizing = false;
    let dragController = null;
    let resizeController = null;
    let dragOffset = new THREE.Vector3();
    let originalScreenScale = new THREE.Vector3(1, 1, 1);
    let resizeStartDistance = 0;
    let resizeStartScale = 1;
    
    // Interactive elements
    let screenGroup, resizeHandle;
    const minScale = 0.3;
    const maxScale = 4.0;
    
    // Controller state
    let controllerState = [
      { isPressed: false, wasPressed: false },
      { isPressed: false, wasPressed: false }
    ];

    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 100);
      
      // Complete darkness for cinema effect
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      renderer.setClearColor(0x000000, 1);
      document.body.appendChild(renderer.domElement);

      // Create video elements
      videoElement = document.getElementById('video');
      videoTexture = new THREE.VideoTexture(videoElement);
      videoTexture.minFilter = THREE.LinearFilter;
      videoTexture.magFilter = THREE.LinearFilter;
      
      createVideoScreen();
      
      // Event listeners
      window.addEventListener('resize', onWindowResize);
      document.getElementById('start-button').addEventListener('click', startVR);
      document.getElementById('exit-vr').addEventListener('click', () => { if (xrSession) xrSession.end(); });
      document.getElementById('file-input').addEventListener('change', handleFileSelect);
      
      videoElement.addEventListener('loadeddata', () => {
        updateVideoScreen();
        updateStatus(`Video loaded: ${videoElement.videoWidth}x${videoElement.videoHeight}`);
        isPlaying = true;
      });
    }

    function createVideoScreen() {
      // Create group to hold screen and resize handle
      screenGroup = new THREE.Group();
      
      // Create video screen (16:9 aspect ratio)
      const screenGeometry = new THREE.PlaneGeometry(3.2, 1.8);
      const screenMaterial = new THREE.MeshBasicMaterial({
        map: videoTexture,
        side: THREE.FrontSide
      });
      
      videoScreen = new THREE.Mesh(screenGeometry, screenMaterial);
      screenGroup.add(videoScreen);
      
      // Create resize handle in bottom-right corner
      const handleGeometry = new THREE.SphereGeometry(0.08, 16, 16);
      const handleMaterial = new THREE.MeshBasicMaterial({
        color: 0x667eea,
        transparent: true,
        opacity: 0.8
      });
      
      resizeHandle = new THREE.Mesh(handleGeometry, handleMaterial);
      resizeHandle.position.set(1.6, -0.9, 0.01); // Bottom-right corner
      screenGroup.add(resizeHandle);
      
      // Position screen in front of user
      screenGroup.position.set(0, 1.6, -2.5);
      scene.add(screenGroup);
    }
    
    function updateVideoScreen() {
      if (videoTexture) {
        videoTexture.needsUpdate = true;
      }
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    function handleFileSelect(event) {
      const file = event.target.files[0];
      if (!file) return;
      
      document.getElementById('selected-file').textContent = `Selected: ${file.name}`;
      
      if (currentVideoURL) {
        URL.revokeObjectURL(currentVideoURL);
      }
      
      currentVideoURL = URL.createObjectURL(file);
      videoElement.src = currentVideoURL;
      videoElement.load();
    }
    
    function startVR() {
      if (!navigator.xr) {
        updateStatus('WebXR not supported in this browser');
        return;
      }
      
      if (!videoElement.src) {
        updateStatus('Please select a video file first');
        return;
      }
      
      navigator.xr.isSessionSupported('immersive-vr')
        .then(supported => {
          if (supported) {
            navigator.xr.requestSession('immersive-vr', { 
              optionalFeatures: ['hand-tracking'] 
            })
              .then(onSessionStarted)
              .catch(err => updateStatus('Failed to start VR session: ' + err.message));
          } else {
            updateStatus('VR not supported on this device');
          }
        })
        .catch(err => updateStatus('Error checking VR support: ' + err.message));
    }
    
    function onSessionStarted(session) {
      xrSession = session;
      document.getElementById('overlay').style.display = 'none';
      document.body.classList.add('vr-active');
      
      renderer.xr.setReferenceSpaceType('local');
      renderer.xr.setSession(session);
      
      // Setup controllers
      controllers = [0, 1].map(i => {
        const controller = renderer.xr.getController(i);
        
        controller.addEventListener('selectstart', () => handleSelectStart(i));
        controller.addEventListener('selectend', () => handleSelectEnd(i));
        
        scene.add(controller);
        
        // Add controller ray visualization
        const geometry = new THREE.BufferGeometry().setFromPoints([
          new THREE.Vector3(0, 0, 0),
          new THREE.Vector3(0, 0, -1)
        ]);
        const material = new THREE.LineBasicMaterial({ 
          color: 0x667eea,
          transparent: true,
          opacity: 0.5
        });
        const line = new THREE.Line(geometry, material);
        controller.add(line);
        
        return controller;
      });
      
      renderer.setAnimationLoop(render);
      session.addEventListener('end', onSessionEnd);
      
      // Auto-play video
      if (videoElement && videoElement.src) {
        playVideo();
      }
      
      updateStatus('Welcome to VR Cinema! Grab the screen to move it around.');
    }
    
    function handleSelectStart(controllerIndex) {
      const controller = controllers[controllerIndex];
      controllerState[controllerIndex].isPressed = true;
      
      // Check what we're pointing at
      const raycaster = new THREE.Raycaster();
      const tempMatrix = new THREE.Matrix4();
      tempMatrix.identity().extractRotation(controller.matrixWorld);
      
      raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
      raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
      
      // Check intersection with resize handle first
      const handleIntersect = raycaster.intersectObject(resizeHandle);
      if (handleIntersect.length > 0) {
        startResize(controllerIndex);
        return;
      }
      
      // Check intersection with video screen
      const screenIntersect = raycaster.intersectObject(videoScreen);
      if (screenIntersect.length > 0) {
        startDrag(controllerIndex, screenIntersect[0].point);
        return;
      }
    }
    
    function handleSelectEnd(controllerIndex) {
      const wasPressed = controllerState[controllerIndex].isPressed;
      controllerState[controllerIndex].isPressed = false;
      
      if (dragController === controllerIndex) {
        stopDrag();
      }
      
      if (resizeController === controllerIndex) {
        stopResize();
      }
      
      // Quick tap to play/pause (only if not dragging/resizing)
      if (wasPressed && !isDragging && !isResizing && dragController !== controllerIndex && resizeController !== controllerIndex) {
        togglePlayPause();
      }
    }
    
    function startDrag(controllerIndex, intersectionPoint) {
      isDragging = true;
      dragController = controllerIndex;
      
      // Calculate offset from screen center to intersection point
      const screenWorldPosition = new THREE.Vector3();
      screenGroup.getWorldPosition(screenWorldPosition);
      
      dragOffset.copy(intersectionPoint).sub(screenWorldPosition);
      
      updateStatus('Dragging screen - move controller to reposition');
    }
    
    function stopDrag() {
      isDragging = false;
      dragController = null;
      dragOffset.set(0, 0, 0);
      
      updateStatus('Screen repositioned');
    }
    
    function startResize(controllerIndex) {
      isResizing = true;
      resizeController = controllerIndex;
      
      const controller = controllers[controllerIndex];
      const controllerPosition = new THREE.Vector3();
      controller.getWorldPosition(controllerPosition);
      
      const screenPosition = new THREE.Vector3();
      screenGroup.getWorldPosition(screenPosition);
      
      resizeStartDistance = controllerPosition.distanceTo(screenPosition);
      resizeStartScale = screenGroup.scale.x;
      
      updateStatus('Resizing screen - move controller closer/further to resize');
    }
    
    function stopResize() {
      isResizing = false;
      resizeController = null;
      
      updateStatus('Screen resized');
    }
    
    function updateDrag() {
      if (!isDragging || dragController === null) return;
      
      const controller = controllers[dragController];
      const controllerPosition = new THREE.Vector3();
      controller.getWorldPosition(controllerPosition);
      
      // Apply the offset to maintain relative position
      const newPosition = controllerPosition.sub(dragOffset);
      screenGroup.position.copy(newPosition);
    }
    
    function updateResize() {
      if (!isResizing || resizeController === null) return;
      
      const controller = controllers[resizeController];
      const controllerPosition = new THREE.Vector3();
      controller.getWorldPosition(controllerPosition);
      
      const screenPosition = new THREE.Vector3();
      screenGroup.getWorldPosition(screenPosition);
      
      const currentDistance = controllerPosition.distanceTo(screenPosition);
      const distanceRatio = currentDistance / resizeStartDistance;
      const newScale = Math.max(minScale, Math.min(maxScale, resizeStartScale * distanceRatio));
      
      screenGroup.scale.setScalar(newScale);
      
      // Update resize handle position to match new scale
      resizeHandle.position.set(1.6 * newScale, -0.9 * newScale, 0.01);
    }
    
    function togglePlayPause() {
      if (isPlaying) {
        videoElement.pause();
        isPlaying = false;
        updateStatus('Video paused');
      } else {
        playVideo();
      }
    }
    
    function playVideo() {
      if (videoElement && videoElement.src) {
        videoElement.muted = false;
        
        videoElement.play()
          .then(() => {
            isPlaying = true;
            updateStatus('Playing video');
          })
          .catch(error => {
            updateStatus('Trying muted playback...');
            videoElement.muted = true;
            videoElement.play()
              .then(() => {
                isPlaying = true;
                updateStatus('Playing video (muted)');
              })
              .catch(err => {
                updateStatus('Playback failed: ' + err.message);
              });
          });
      }
    }
    
    function render() {
      // Update interactions
      updateDrag();
      updateResize();
      
      // Update controller state
      controllerState.forEach((state, index) => {
        state.wasPressed = state.isPressed;
      });
      
      // Update video texture
      if (videoTexture && videoElement.readyState >= videoElement.HAVE_CURRENT_DATA) {
        videoTexture.needsUpdate = true;
      }
      
      // Make resize handle glow when being interacted with
      if (isResizing) {
        resizeHandle.material.opacity = 0.9 + 0.1 * Math.sin(Date.now() * 0.01);
      } else {
        resizeHandle.material.opacity = 0.6;
      }
      
      renderer.render(scene, camera);
    }
    
    function onSessionEnd() {
      document.getElementById('overlay').style.display = 'flex';
      document.body.classList.remove('vr-active');
      document.getElementById('status').style.display = 'none';
      
      if (videoElement) {
        videoElement.pause();
        isPlaying = false;
      }
      
      // Reset interaction state
      isDragging = false;
      isResizing = false;
      dragController = null;
      resizeController = null;
      
      renderer.setAnimationLoop(null);
      xrSession = null;
    }
    
    function updateStatus(message) {
      const statusElement = document.getElementById('status');
      statusElement.textContent = message;
      statusElement.style.display = 'block';
      
      if (!message.toLowerCase().includes('error') && 
          !message.toLowerCase().includes('failed')) {
        setTimeout(() => { statusElement.style.display = 'none'; }, 3000);
      }
    }
    
    function cleanup() {
      if (currentVideoURL) {
        URL.revokeObjectURL(currentVideoURL);
      }
      
      if (xrSession) {
        xrSession.end();
      }
    }
    
    window.addEventListener('beforeunload', cleanup);
    
    // Initialize app
    init();
  </script>
</body>
</html>
